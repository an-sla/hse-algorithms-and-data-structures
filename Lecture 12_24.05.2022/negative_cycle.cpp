#include <iostream>
#include <vector>

// ИМЕЕМ ОРГРАФ, ИЩЕМ ЦИКЛ ОТРИЦАТЕЛЬНОГО ВЕСА:

const int inf = 1e9; // максимальное расстояние — inf

struct edge {
    // f – откуда, t – куда, w – вес
    int f = 0, t = 0, w = 0;
};

int main() {
    // n – количество вершин
    // m – количество рёбер
    // vertex – вершина, из которой мы начинаем строить дерево кратчайших расстояний
    int n, m, vertex;
    std::cin >> n >> m >> vertex;
    std::vector<edge> e(m); // список рёбер

    // инициализация графа с помощью списка рёбер (матрицы инцидентности)
    for (int i = 0; i < m; ++i) {
        std::cin >> e[i].f >> e[i].t >> e[i].w;
    }

    std::vector<int> p(n, -1); // список предков = наше дерево кратчайших расстояний
    std::vector<int> dist(n, inf); // массив построенных расстояний

    dist[vertex] = 0; // расстояние до корня дерева фиксируем равным 0

    std::vector<int> improve; // массив, хранящий вершины, которые затрагиваются на первом неоптимальном проходе по отрицательному циклу

    for (int k = 0; k < n; ++k) { // делаем k < n, а не k < n - 1
        for (int i = 0; i < e.size(); ++i) {
            int f = e[i].f, t = e[i].t, w = e[i].w;
            if (dist[f] == inf) { // если расстояние до исходящей вершины для данного ребра = бесконечности, пропускаем, не можем произвести релаксацию (=улучшение), мы до неё ещё не ходили, чтобы из неё пойти дальше
                continue;
            }
            if (dist[f] + w < dist[t]) { // если мы заходим в этот if, значит, можем произвести обновление
                dist[t] = dist[f] + w; // фиксируем расстояние
                p[t] = f; // фиксируем предка
                // если мы заходим в этот if, значит, мы делаем n-е улучшение. Это означает, что есть отрицательный цикл, так как в оптимальном дереве кратчайших расстояний не может быть больше, чем n - 1 ребро
                if (k == n - 1) {
                    improve.push_back(t); // добавляем вершину to в специально созданный для этого массив
                }
            }
        }
    }

    // вывод вершин, достижимых из цикла отрицательного веса:
    for (int i = 0; i < improve.size(); ++i) {
        std::cout << improve[i] << " ";
    }

    std::cout << std::endl;

    // вывод полученного дерева:
    for (int i = 0; i < p.size(); ++i) {
        if (p[i] == -1) {
            continue; // (если предка нет, не выводим ничего)
        }
        std::cout << i << "->" << p[i] << ";" << std::endl;
    }
    return 0;
}

/*
Test Input 1:
5 5 0
0 1 1
1 2 1
2 3 -1
3 1 -1
2 4 1

Test Output 1:
2 3 1 4
3->1;
1->2;
2->3;
2->4;

Test Input 2:
5 5 0
2 4 1
3 1 -1
2 3 -1
1 2 1
0 1 1

Test Output 2:
4 3
3->1;
1->2;
2->3;
2->4;
*/