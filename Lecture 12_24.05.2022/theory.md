# Алгоритм Флойда

- Работаем с ориентированным графом, но хотим избежать цикл отрицательного веса или ситуацию, где ноды ссылаются друг на друга с отрицательным весом (n1 <—> n2, фактически отрицательный цикл с 2 рёбрами);

- В начальном коде `negative_cycle.cpp` просто используем алгоритм Беллмана-Форда находим вершины, которые достижимы из отрицательного цикла (в качестве детектора — n–нный проход), гарантируется, что хотябы одна из них лежит в отрицательном цикле;

<ins> Алгоритм Флойда: </ins>

- Пример решения во `floyd.cpp`;
- Решает задачу как для орграфов, так и для неориентированных графов;
- Решает задачу построения дерева кратчайщих расстояний из каждой вершины до всех достижимых;
- Не работает на графах с отрицательными весами рёбер;
- Асимптотика O(n^3);

- На выходе получаем матрицу расстояний A — из каждой вершины до каждой (номера вершин по строкам и столбцам); 
  - Изначально по диагонали — 0, всё остальное — inf;
- Используем вспомогательные матрицы A_0, A_1, A_2, ...:
  - Каждая из матриц строится на основе предыдущей;
  - K-ая матрица учитывает вершины от 0 до k включительно;
  - K-ая матрица хранит в себе расстояния между парами вершин i<->j, которые проходят через вершину с номером k, тем самым улучшая путь между вершинами i, j;
  - Если происходит улучшение — обновляем расстояние в матрице результатов A;
