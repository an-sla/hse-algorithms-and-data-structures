#include<iostream>
#include<vector>

// Задача 3 из контеста — количество компонент связности в неориентированном невзвешенном графе:

// (путь тут не нужен)

std::vector<int> used;
std::vector<std::vector<int>> g;

void dfs(int v, std::vector<int>& comps, int z) {
    used[v] = 1; // пометили вершину
    comps[v] = z; // пометили нужной компонентой связности по индексу
    for (auto to : g[v]) { // смотрим все инцидентные вершины
        if (!used[to]) { // если в этой вершине ещё не были...
            dfs(to, comps, z); // запускаем из неё dfs
        }
    }
}

int main() {
    int n = 0, m = 0;
    std::cin >> n >> m;
    n++;
    g = std::vector<std::vector<int>> (n); // делаем размер списка смежности на 1 больше для "хорошей" нумерации индексов
    for (size_t i = 0; i < m; ++i) { // заполняем список смежности
        int f = 0, t = 0;
        std::cin >> f >> t; // добавляем to, from
        g[f].push_back(t);
        g[t].push_back(f);
    }
    used = std::vector<int> (n); // "раскрашенные" ноды
    used[0] = 1;
    std::vector<int> comps(n, 0); // компоненты связности для каждой ноды (ноды лежат по индексу, нумеруются с 1, но для n мы уже сделали ++ -> размерности совпадают)
    int cnt = 0; // количество компонент связности
    for (size_t i = 1; i < used.size(); ++i) { // рассмотрим каждую вершину
        if (used[i] == 0) { // если мы не были в вершине...
            cnt += 1; // так как мы запускаем рекурсивный dfs, который обходит всю компоненту связности, то раз мы не были в вершине, то у нас новая компонента
            dfs(i, comps, cnt); // передаём:
            // начальную вершину, (пустой) путь, вектор, куда запишем компоненту связности и номер текущей компоненты для записи во все вершины пройденные в рекурсии
        }
    }
    std::cout << cnt << std::endl; // выводим количество компонент
    for (auto i = 1; i < comps.size(); ++i) { // выводим, какой компоненте принадлежит какая вершина, начиная с 1
        std::cout << comps[i] << ' ';
    }
    return 0;
}

// OK
