# Алгоритм Краскала

<ins>Алгоритм Краскала — повторение:</ins>
- Задача построения кратчайшего связывающего дерева (дерево — связный граф без циклов);
- **$G = {N, E, f(e)}$** — имеем граф;
- Множество вершин графа и связывающего дерева совпадают;
- Связывающее (остовное) дерево содержит только рёбра исходного графа (из их множества мы постепенно добавляем в дерево);
- Длина дерева — сумма всех длин входящих в дерево рёбер;
- При добавлении очередного ребра проверяем на то, что 2 соединяемые вершины НЕ лежат в 1 компоненте связности — тогда можем добавить ребро в остовное дерево;
<br></br>

<ins>Дерево поиска:</ins>
- Двоичное дерево, где выполняется соотношение поиска:
  - Для каждого элемента дерева все элементы левого поддерева меньше, чем этот элемент (корень), а все элементы правого поддерева — больше;
  - При этом считаем, что у нас нет повторяющихся элементов; 
- Решаем задачи:
  - Найти — включает задачу есть/нет элемента;
  - Добавить;
  - Удалить;

В целом для дерева — мин. в самом правом поддереве, макс. в самом левом поддереве;

- **Найти:** идём по дереву налево или направо, пока не найдём искомый элемент.
- **Добавить:** подвешиваем новый элемент в лист соотвествующей ветки, не нарушая порядка построения дерева.
- **Удалить:** рассматриваем самый левый элемент правого поддерева и самый правый элемент правого поддерева — ищем элемент, который ближе всего к удалённому элементу и из них выбираем самый левый элемент правого поддерева, так как он будет больше всех из левого, но меньше всех из правого;
<br></br>

<ins>АВЛ дерево:</ins>
- Обозначим $HL$ — глубину левого поддерева, $HR$ — глубину правого поддерева;
- **Баланс вершины (корня)** = $\mod{(HL - HR)}$;
- Дерево сбалансированно, когда баланс каждой из вершин ≤ 1;
- Заметим, что $f(h) = f(h - 1) + f(h - 2) + 1$, где $f(h)$ — минимальное количество элементов в АВЛ дереве высотой $h$; это последовательность чисел Леонардо;
- АВЛ дерево растёт логарифмически — $O(const \cdot \log n)$.

