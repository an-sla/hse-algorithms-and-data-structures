# Корневая эвристика / Sqrt декомпозиция. Алгоритм МО.

## Корневая эвристика
- Обрабатывает задачи, где длина массива — полный квадрат;

<ins>Реализуем решение задачи о RSQ:</ins>

- Для поиска суммы на подотрезке разобьем наш исходный массив на sqrt(n) подмассивов длины sqrt(n). Для каждого подмассива длины sqrt(n) мы считаем сумму или нужную функцию и записываем в новый массив (назовём new, он будет иметь длину sqrt(n));
- Такой препроцессинг займёт O(n), так как нам придется проитерироваться по всему массиву для подсчёта суммы на каждом из подотрезков, которые покрывают все n элементов;
- Дальше при каждом запросе типа l, r мы будем суммировать полностью ячейки из new, если у нас подотрезку [l, r] соответствует (и влезает туда) хотя бы один ровный квадрат, если же заданный интервал слишком маленький, то обращаемся напрямую к исходному массиву;
- Для подсчёта крайних “хвостов”, которые лежат за рамками данного полного квадрата (полных квадратов, если |r-l| > 1*sqrt(n)) мы тоже обращаемся к исходному массиву;
- Таким образом, асимптотика одного запроса будет порядка O(sqrt(n));
<br></br>
- Для увеличения одного элемента нам надо увеличить элемент в исходном массиве (произойдет за O(1), так как по сути речь идет о доступе к элементу массива). Дальше надо “пересчитать” соответствующую ячейку в new, куда входит подотрезок с этим элементом. Это произойдёт тоже за O(1) ввиду сложности доступа для вектора. Просто прибавляем к данной ячейке в new число x, если наша функция была RSQ / sum;

Пример задачи в `sqrt_decomposition.cpp`;

## Алгоритм Мо
- Вместо обработки задач "онлайн" (последовательно по мере поступления), решает задачи оффлайн (сначала собирает их, упорядочивает и оптимизирует, затем считает и даёт вывод);
- Помогает обработать запрос например о сумме (но также о мин, макс) на подотрезке [L_2, R_2], если уже посчитана сумма на некотором подотрезке [L_1, R_1];

<ins>Реализуем решение задачи Алгоритма Мо:</ins>

- Для избежания решения каждого запроса за линейное время, упорядочиваем запросы по левому концу в мысленных ячейках i * sqrt(n) (где i = {0, 1, 2 ... }), затем внутри ячеек упорядочиваем по правому концу;
- Асимптотика левого конца для запросов из каждой ячейки будет O(sqrt(n)), для правого конца — O(n) — для одного такого блока мы потратим O(sqrt(n) * k_0) + n ресурсов, где k_0 — количество запросов в данном блоке;
- Таким образом, асимптотика решения всех запросов будет для левой границы O(m * sqrt(n)), где m — количество запросов, для правой границы будет O(n * sqrt(n)), итого: O(m * sqrt(n)) + n * sqrt(n));
- Улучшить алгоритм (в 2 раза) можно с помощью дополнительного упорядочивания запросов по правой границе для каждого блока — либо в порядке возрастания, либо в порядке убывания;
- В структуре программы имеем:
  - Компаратор для запросов;
  - Алгоритм сравнения и добавления на отрезке;
  - Пробег по всем запросам;
  

**Пример задачи в [`Mo's_algorithm.cpp`](https://github.com/an-sla/hse-algorithms-and-data-structures/blob/main/Lecture%204_14.04.2022/Mo's_algorithm.cpp);**

**Домашнее задание по теме совместно с "Лекцией 3" — лежит в [этой папке](https://github.com/an-sla/hse-algorithms-and-data-structures/tree/main/Lecture%203_12.04.22/HW%203);**

**[Дополнительные материалы](https://algorithmica.org/ru/sqrt).**

