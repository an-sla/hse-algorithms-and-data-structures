# Система непересекающихся множеств, Алгоритм Краскала.

- Система непересекающихся множеств используется в алгоритме Краскала;
- Хотим отвечать на 2 запроса: find(a), union(a, b);
  - find(a) — вернуть номер множества для элемента a;
  - union(a, b) — объединений 2 множеств с данными номерами;
- В наивной реализации:
  - find работает за O(1);
  - union (перекраска) работает в худшем случае за O(n), так как нам прийдётся пройтись по всему массиву;
- При реализации, где меньшее множестве переходит в большее (ориентируемся на ранг = размер каждого множества):
  - Find(a) — O(1) при инициализации (доступ по индексу в массиве), после — O(n), так как мы можем получить длинную “цепочку”, где нам придётся при find(a) идти итеративно до корня: find(a) = b, find(b) ≠ -1 → find(b) = c, find(c) ≠ -1 → … → find(n) = -1;
  - Мы на 1 перекраску потратим O(log_2 n) операций, так как каждый элемент оказывается при очередной касающейся его перекраске в множестве в 2 и более раз большем предыдущего;
  - В худшем случае перекрашиваем каждый элемент на каждой итерации — O(n log_2 n) асимптотика для всех перекрасок в алгоритме;

<img width="1061" alt="Screenshot 2022-06-24 at 12 03 52" src="https://user-images.githubusercontent.com/101647250/175513587-c9418733-66ac-4511-8770-8ad900d2c7ba.png">      
<br></br>

<ins>Альтернативный алгоритм — реализуем с помощью списка предков:</ins>
- Множество — это дерево представленное списком предков;
- Номер корня — это номер множества;
- Новые определения функций:
  - find(a) — вернуть номер корня;
  - union(a, b): p[find(a)] = find(b) — присваеваем новый "корень";

<img width="1061" alt="Screenshot 2022-06-24 at 12 02 57" src="https://user-images.githubusercontent.com/101647250/175513584-56ab8fe1-ea17-4595-9b3f-55a0e604276b.png">
<br></br>

<ins>Улучшение алгоритма:</ins>
- Если у нас возникает случай, где все ноды висят друг за другом, то перестраиваем граф с помощью алгоритма сжатия путей — строим "ежей";
- Затем "ежей" подвешиваем друг к другу и перестраиваем до нового ежа;
- Асимптотики — если работать с массивом:
  - Find(a) — O(1), доступ по индексу в массиве, сжатие путей гарантирует, что мы получим именно самый высоко лежащий корень;
  - Merge(a, b) — O(log log log… n) = O(G(n)), где G — медленно растущая функция.



<img width="1061" alt="Screenshot 2022-06-24 at 12 02 07" src="https://user-images.githubusercontent.com/101647250/175513581-313400e2-a43a-4e65-ba72-4e9c59d5b278.png">
<br></br>

<ins>Алгоритм Краскала:</ins>
- Задача построения кратчайшего связывающего (остовного) дерева (дерево — связный граф без циклов);
- G = {N, E, f(e)} — имеем граф;
- Множество вершин графа и связывающего дерева совпадают;
- Связывающее дерево содержит только рёбра исходного графа (из их множества мы постепенно добавляем в дерево);
- Длина дерева — сумма всех длин входящих в дерево рёбер;
- Сортируем длины рёбер по возрастанию;
- Постепенно добавляем, проверяя, не лежат ли инцидентные вершины в одной компоненте связности;


<img width="1061" alt="Screenshot 2022-06-24 at 12 01 32" src="https://user-images.githubusercontent.com/101647250/175513575-2ae7cdd6-157b-4c5d-ad28-d0a0bbc2b5cf.png">





