# Система непересекающихся множеств, Алгоритм Краскала.

- Система непересекающихся множеств используется в алгоритме Краскала;
- Хотим отвечать на 2 запроса: find(a), union(a, b);
  - find(a) — вернуть номер множества для элемента a;
  - union(a, b) — объединений 2 множеств с данными номерами;
- В наивной реализации:
  - find работает за O(1);
  - union (перекраска) работает в худшем случае за O(n), так как нам прийдётся пройтись по всему массиву;
- При реализации, где меньшее множестве переходит в большее:
  - find работает за O(n);
  - Мы на перекраску потратим O(log_2 n) операций, так как каждый элемент оказывается при очередной касающейся его перекраске в множестве в 2 и более раз большем предыдущего;
  - Каждый элемент в худшем случае перекрашиваем — O(n log_2 n) асимптотика, если ;
      <br></br>

<ins>Альтернативный алгоритм:</ins>
- Множество — это дерево представленное списком предков;
- Номер корня — это множества;
- Новые определения функций:
  - find(a) — вернуть номер корня;
  - union(a, b): p[find(a)] = find(b) — присваеваем новый "корень";
  

<ins>Улучшение алгоритма:</ins>
- Если у нас возникает случай, где все ноды висят друг за другом, то перестраиваем граф с помощью алгоритма сжатия путей — строим "ежей";
- Затем "ежей" подвешиваем друг к другу и перестраиваем до нового ежа;
<br></br>

<ins>Алгоритм Краскала:</ins>
- Задача построения кратчайшего связывающего (остовного) дерева (дерево — связный граф без циклов);
- G = {N, E, f(e)} — имеем граф;
- Множество вершин графа и связывающего дерева совпадают;
- Связывающее дерево содержит только рёбра исходного графа (из их множества мы постепенно добавляем в дерево);
- Длина дерева — сумма всех длин входящих в дерево рёбер;
- Сортируем длины рёбер по возрастанию;
- Постепенно добавляем, проверяя, не лежат ли инцидентные вершины в одной компоненте связности.

