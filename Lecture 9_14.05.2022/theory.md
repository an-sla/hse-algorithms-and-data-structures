# Задача нахождения кратчайших путей в графе. Общий алгоритм. Обход в ширину.

- Задан взвешенный ориентированный граф **G** = **{*N, A, f(A)*}** (множество вершин **N**, множество дуг **A**, с функцией **f(A)** на дугах);
- Длина пути: подсчёт значений (функции) ребер на пути;
<br></br>

<ins>Виды задач:</ins>

_Решаются преимущественно за счёт жадных алгоритмов;_

_Нет гарантий, что у нас 1 компонента связности и что каждая вершина достижима из каждой;_
1. Сеть с ***<ins>единичными длинами</ins>*** дуг **f(A) = 1**:
   - Решение с помощью обхода в ширину (**BFS**);
   - Решение маштабируется;
2. Сеть с ***<ins>неотрицательными</ins>*** длинами дуг **f(A) > 0**:
   - Могут быть вещественные числа, вместо суммы кратчайшего пути можно искать произведение;
   - Решается с помощью **алгоритма Дейкстры**;
3. Сеть с ***<ins>произвольными</ins>*** длинами — *отсутствие отрицательного цикла* гарантировано, но дуги ***могут иметь отрицательные значение***:
   - **Алгоритм Беллмана-Форда**;
4. Сеть с произвольными длинами — ***<ins>отсутствие отрицательного цикла НЕ гарантировано</ins>***.
   - Найдём цикл отрицательного веса — с его помощью смысл задачи теряется (можем бесконечно ездить по циклу);
   - Отрицательный цикл удаляется;
   - На оставшемся графе применяем **алгоритм Беллмана-Форда**;
5. Ациклическая сеть
   - Другой класс алгоритмов — **динамика на графах**;

<br>
<ins>Решаем задачу сети с единичными длинами дуг:</ins>

- Хотим построить ***дерево кратчайших расстояний*** — из одной (нулевой) вершины во все;

- Из данной задачи, построив дерево, можем найти ответ на более узкую задачу — кратчайший путь из какой-то вершины в другую:
  - Тогда надо строить новое дерево кратчайших расстояний из той вершины, откуда мы идём в задаче (общее дерево из какой-то нулевой вершины не решит подзадачу кратчайшего пути из 2 рандомных вершин);

- Количество рёбер = длина пути;

- Обход в ширину — **BFS**:
    1. С помощью очереди — выбираем вершину **"0"**, а все расстояния для каждой вершины обозначаем как **+inf**;

    2. Ранг вершины = количество рёбер в (пройденном) пути — в стартовой она равна **0**;

    3. Последовательно помещаем вершины, до которых мы дотягиваемся из **"0"** в очередь — "на рассмотрение" (помечаем, где мы уже были);

    4. Постепенно забираем вершины из начала очереди — после рассмотрения всех вершин с рангом **1** переходим по индукции к вершинам с рангом **2**;

    5. Два раза в одну вершину не ходим;

- Таким образом формируется дерево кратчайших путей;

- При рассмотрении **R**, следующий уровень в дереве нам гарантирует **R + 1** (количество рёбер в пути либо остаётся ***прежним***, либо увеличивается на **1**);

**Визуализация:**

<img width="1105" alt="Screenshot 2022-06-24 at 18 46 39" src="https://user-images.githubusercontent.com/101647250/175604817-71de9283-5863-427b-aafe-171ff82173f8.png">
<img width="1105" alt="Screenshot 2022-06-24 at 18 46 54" src="https://user-images.githubusercontent.com/101647250/175604824-2e916bce-5de5-4cdd-95b9-2e56de3f8de4.png">
<img width="1105" alt="Screenshot 2022-06-24 at 18 47 08" src="https://user-images.githubusercontent.com/101647250/175604831-e0d89447-eefd-424b-86f8-c657c7e320fa.png">
<img width="1105" alt="Screenshot 2022-06-24 at 18 46 26" src="https://user-images.githubusercontent.com/101647250/175604806-e8b88f85-58ab-4c1a-b855-db0806737669.png">

<br></br>
- В общем случае нам не нужна очередь:
  - Изменим задачу с различными длинами дуг — добавим несколько длин со значением **2**;
  - Сейчас рассматривая **R**, мы можем получить как **R + 1**, так и **R + 2**;
  - Возмём несколько множеств ("черпаки — buckets" = неоптимально, но структура используется для понимания):

    1. Первый черпак r0 хранит все вершины, расстояние до которых равно 0;
    2. Второй черпак r1 — хранит все вершины, расстояние до которых равна 1 и тд.;
    3. Макс. количество черпаков — **(N - 1) * 2** = (количество вершин - **1**, т.е. количество рёбер) * (макс. вес/длина пути);
    4. Постепенно проходимся по черпакам и просматриваем вершины и исходящие из них дуги — добавляем новые вершины в соответствующие черпаки по мере того, как до них "дотягиваемся";
    5. Важно: если мы до какой-то вершины находим более оптимальный путь, то мы удаляем её из неоптимальных черпаков;
    6. Максимальное предполагаемое количество черпаков необязательно равно реально достигнутому;

  - Данный алгоритм можно было "зациклить":

    1. Используем 3 бакета: **r<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>** — множество **r<sub>0</sub>** , которое мы просматриваем + множества **r<sub>1</sub> , r<sub>2</sub>** , которые мы пополняем по мере просмотра **r<sub>0</sub>**;
    2. Потом **сдвигаем** бакеты на 1 — **r<sub>1</sub>  переходит в r<sub>0</sub>**  и повторяем процесс. Таким способом мы перезаписываем расстояния;
    3. Суммарные расстояния пишем отдельно в массив;
    4. Если для нашей задачи количество черпаков будет слишком большим, то мы можем их "схлопнуть" в кучу или в сет (алгоритм Дейкстры);
  
