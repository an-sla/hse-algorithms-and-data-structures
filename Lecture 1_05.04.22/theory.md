### Классификация алгоритмов 1

С точки зрения характера получаемого решения:

1. _Точные алгоритмы_ = дают точное решение, например: минимум в массиве;
2. _Приближённые алгоритмы_ = дают приближённое решение (с некоторой точностью, до нескольких знаков после запятой), например: поиск корня, работа с типом `double` в С++; 
3. _Эвристические алгоритмы_ = с точки зрения математики не должны работать, но на хороших данных могут дасть результат;
4. _Вероятностные алгоритмы_ = например: хэш таблица (можем посчитать и оценить вероятность коллизий в хэш таблице);

### Классификация алгоритмов 2

1. Последовательные алгоритмы = последовательно выполняем действия, не можем начать «из середины»;
2. Параллельные алгоритмы = можно запустить несколько процессов одновременно (на видеокарте), процессы независимы, например, умножение матриц;

### Классификация алгоритмов 3

1. Детерминированные алгоритмы — для одних и тех же данных мы будем совершать одни и те же действия (не только один и тот же результат), например сортировка пузырьком;
2. Рандомизированыные алгоритмы — при каждой итерации алгоритм выбирает новое действие, каждое новое действие может произойти с какой-то вероятностью;

<hr>  
<br>

## Теория чисел

### Алгоритм Евклида
a > b -> НОД(а, b) = НОД(b, r) : a = b * k + r

**Пример:**
| | I. | II. | III. |
| :---: | :---: | :---: | :---: |
| A | 2020 | 42 | 4 |
| B | 42 | 4 | 2 |
| R | 4 | 2 | 0 |

**Пример 2 (работает долго):**

Два соседних числа Фибоначчи (взаимно простые числа):

| | I. | II. | III. | IV. |  V. |  VI. |  VII. | VIII. | IX. | X. | XI. |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | 
| A | 233 | 144 | 89 | 55 | 34 | 21 | 13 | 8 | 5 | 3 | 2 |
| B | 144 | 89 | 55 | 34 | 21 | 13 | 8 | 5 | 3 | 2 | 1 |
| R | 89 | 55 | 34 | 21 | 13 | 8 | 5 | 3 | 2 | 1 | 0 |

233 — F_13, а 144 — F_12 в ряду Фибоначчи;

Следовательно, здесь можно установить закономерность, что НОД(F_n+1, F_n) вычисляется за n операций, если F_0 = 1, F_1 = 1;

Для НОД(F_n+1, F_n-1) количество вычислений будет тоже n;
<br></br>
### НОК
НОК(a, b) = a * b / НОД(a, b);

Чтобы небыло переполнения, порядок операций можно поменять: НОК(a, b) = a / НОД(a, b) * b;
<br></br>
### Факторизация
- Разложение числа на множители
<img width="818" alt="Screenshot 2022-04-21 at 17 08 59" src="https://user-images.githubusercontent.com/101647250/164488956-58e0fd09-5b13-4328-84c7-a0b239b19b10.png"><br></br>

### Решето Эратосфена
- Принцип состоит в том, чтобы из массива с 1 вычёркивать все кратные каждого нового простого числа;
- Возможна реализация с обходом начиная с 2 * i или с i * i;
- Для нахождения n простых чисел можно применить стратегию "подгадать ответ" — если нам нужно макс. k-тое простое число в запросах, то строим массив размера минимум k+1;
<br></br>
### Большие простые числа
Имеем A < B; A, B ≤ 10^12; B-A ≤ 10^6;

Хотим найти простые числа на отрезке от A до B;

Берём простые числа из интервала (0, 10^6] → на интервале от А до B порядка 10^6 находим числа, которые делятся на простые числа с интервала (0, 10^6] в начале числовой прямой;
<br></br>
### Быстрое возведение в степень
a^n:

- n = чётное — a^n = (a^2)^n;
- n = нечётное — a * a^(n-1);

→ Работает за O(log n) операций;


