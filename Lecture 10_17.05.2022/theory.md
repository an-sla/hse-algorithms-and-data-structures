# Алгоритм Дейсктры

- Снова рассматриваем алгоритм нахождение кратчайших путей;
  <br></br>

<ins>Решим BFS без очереди:</ins>
- Асимптотически работает за константу больше, чем в случае с очередью, но фактически за то же самое время;
<br></br>

- Далее хотим построить дерево кратчайших расстояний для графа, где расстояния (веса рёбер) неединичные;
- Пусть есть граф $G = \{N, E, f(e)\}$, где $f(e)$ — вес ребра от 1 до $n$;
- Наивная реализация состоит в создании n векторов, куда мы будем класть вершины на расстояниях от 1 до n от нашей стартовой вершины, затем от вершин, куда мы перешли из стартовой и так далее;
- Дополнительно храним массив расстояний — путь нашего обхода в графе (будем менять, если можем улучшить);
- Для макс. веса ребра — 3:
  - Воспользуемся четырьмя массивами: $rcur, r_1, r_2, r_3$ (последние три смотрят расстояния от текущей вершины на +1,+2,+3 больше, соответственно); ещё есть $dist$, в котором $dist[any] = \infin, \;\ dist[1] = 0$ в начальный момент времени;


- Проблема возникает, когда n — слишком большое, тогда хранить n массивов будет дорого;

<br></br>
<ins>Применим алгоритм Дейкстры:</ins>
- e