#include <iostream>
#include <vector>
#include <climits>

// Задача на поиск кратчайших расстояний:
int main() {
    int n = 0; // количество вершин
    int m = 0; // количество рёбер
    std::cin >> n >> m;
    std::vector<std::vector<int>> g(n); // список смежности — размерности по количеству вершин
    // ... заполняем граф (цикл = количество рёбер):
    for (size_t i = 0; i < m; ++i) {
        int f = 0, t = 0;
        std::cin >> f >> t;
        // неориентированный граф:
        g[f].push_back(t);
        g[t].push_back(f);
    }

    std::vector<int> p(n - 1); // создали список предков для сохранения ответов
    std::vector<int> distance(n - 1, std::numeric_limits<int>::infinity()); // массив расстояний, изначально заполнен бесконечностями
    std::vector<int> rcurr, r1; // не обязательно использовать очередь — делаем 2 вектора, rcurr и rcurr+1
    // -> текущее расстояние может порождать лишь расстояние на 1 больше
    // добавили нулевую вершину, с неё начинаем строить расстояние
    rcurr.push_back(0);
    distance[0] = 0; // расстояние до 0 вершины — всё ещё 0
    while (!rcurr.empty() || !r1.empty()) { // работаем, пока текущий вектор и пока следующая очередь не пустые
        // добавим "заглушку" — если наш текущий вектор стал пустым, то мы сдвигаемся:
        if (rcurr.empty()) {
            rcurr = r1;
            r1 = std::vector<int>();
        }

        int cur = rcurr.back(); // "забираем" в качестве curr любую вершину из rcurr — забираем из конца
        rcurr.pop_back(); // выкидываем вершину из вектора
        for (auto to :  g[cur]) { // для вершины curr просматриваем все инцидентные рёбра (вершины):
            if (distance[cur] + 1 < distance[to]) { // проверяем расстояние — если от текущей вершины + 1 мы могли улучшить расстояние, то мы его улучшаем
                distance[to] = distance[cur] + 1; // улучшаем расстояние
                p[to] = cur; // фиксируем в списке предков, что мы пришли в вершину `to` из `current`
                r1.push_back(to); // если появляется улучшение, добавляем ещё одну вершину
            }
        }

    }
    return 0;
}