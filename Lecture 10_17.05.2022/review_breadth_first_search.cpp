#include <iostream>
#include <vector>
#include <queue>
#include <climits>

// ДЛЯ АЛГОРИТМА ДЕЙСКТРЫ РАБОТАЕМ С КОДОМ С ПРЕДЫДУЩЕЙ ЛЕКЦИИ (повторение):

// Задача на поиск кратчайших расстояний:
int main() {
    int n = 0; // количество вершин
    int m = 0; // количество рёбер
    std::cin >> n >> m;
    std::vector<std::vector<int>> g(n); // список смежности — размерности по количеству вершин
    // ... заполняем граф (цикл = количество рёбер):
    for (size_t i = 0; i < m; ++i) {
        int f = 0, t = 0;
        std::cin >> f >> t;
        // неориентированный граф:
        g[f].push_back(t);
        g[t].push_back(f);
    }

    std::vector<int> p(n - 1); // создали список предков для сохранения ответов
    std::vector<int> r(n - 1, std::numeric_limits<int>::infinity()); // массив расстояний, изначально заполнен бесконечностями
    std::queue<int> q; // очередь
    // добавили нулевую вершину, с неё начинаем строить расстояние
    q.push(0);
    r[0] = 0; // расстояние до 0 вершины — 0
    while (!q.empty()) {
        int cur = q.front(); // "забираем" из очереди вершину
        q.pop();
        for (auto to :  g[cur]) { // для вершины curr просматриваем все инцидентные рёбра (вершины):
            if (r[cur] + 1 < r[to]) { // проверяем расстояние — если от текущей вершины + 1 мы могли улучшить расстояние, то мы его улучшали
                r[to] = r[cur] + 1; // улучшаем расстояние
                p[to] = cur; // фиксируем в списке предков, что мы пришли в вершину `to` из `current`
                q.push(to); // добавляем вершину в очередь для просмотра
            }
        }

    }
    return 0;
}


/* тест:
8 10
0 1
0 5
1 2
2 4
2 3
3 4
3 5
5 6
6 4
6 7
*/