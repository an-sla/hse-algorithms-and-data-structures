# Бинарный поиск. Бинпоиск по ответу.

### Вещественный бинарный поиск

<ins>Реализуем поиск вещественного корня на отрезке:</ins>
- Дана функция f(x), которая определена на отрезке [a, b] и имеет ровно один корень на данном отрезке;
- С помощью приближённого (не точного) алгоритма, мы сможем определить данный корень;
- Алгоритм:
  1. Делим пополам — имеем точку m, ищем f(m);
  2. Если между f(a) и f(m) происходит изменение знака — корень лежит на отрезке [a, m], далее используем его;
  3. Повторяем действия до того, как мы максимально (на какое-то эпсилон) не приблизимся к корню;
  
- Важный нюанс:
  - Из-за работы с типом `double` в C++, надо обязательно проверять, что при делении точка m не совпала с корнем, иначе у нас a и b могут поменяться местами за счёт представления вещественных типов;

- Сложность алгоритма:
  - Если у нас отрезок от -10^6 до 10^6 и мы хотим найти корень с точностью до 10^(-6), то мы получим 2*10^6*10^6 делений, пока мы не дойдём до ответа с нужной нам точностью;
  - 10^6 ~ 2^20, следовательно, n = 2^41;
  - За каждую итерацию мы делим отрезок на 2 и количество делений уменьшается в 2 раза;
  - n = 2^41 -> 2^40 -> 2^39 -> ... -> 2^1 -> 2^0 = 1 отрезок;
  - Т.е. до нужной нам точности мы дойдём за log2(n), где n — количество делений или длина массива в целочисленном случае;

Пример вещественного бинпоиска реализован в файле `real_number_binsearch_cubic_func.cpp`;

<br>

### Целочисленный бинарный поиск

<ins>Решаем задачу не/вхождения числа в отсортированный (неубывающий) массив и нахождение индекса вхождения:</ins>
- Нам дан отсортированный массив A с n числами;
- Создаём фиктивный -1 и n+1 элементы (с индексами -1, A.size()) — это нам помогает решитъ подзадачу крайних вхождений крайних элементов или вхождения элементов, превышающих диапазон массива;
- Далее у нас идёт разделение на подзадачи: нахождение первого и последнего вхождения элемента;

Пример первого вхождения реализован в файле `first_entry_binsearch.cpp`, пример последнего вхождения реализован в файле `last_entry_binsearch.cpp`;
Для нахождения количества элементов с нужным нам значением в массиве, используем:

```
size_t first_entry = binary_search_first(number_set, key);
size_t last_entry = binary_search_last(number_set, key);

if (last_entry < first_entry) {
  std::cout << 0 << std::endl;
} else {
  std::cout << (last_entry - first_entry) + 1 << std::endl;
}
```

<br>

### Бинарный поиск по ответу
<ins>Решаем прикладную задачу с фиктивным массивом</ins>
- Имеем переменную с непрерывными неубывающими значениями — она у нас будет служить "массивом", где мы будем искать ответ;
- Однако, нам необязательно считать каждое значение массива (иначе решение превратится в линейный поиск), а вычислять значение O(log2 (N)) раз по заданной формуле;
- Задача также определяет функцию, которая нам задаёт сравнение для сдвига либо L, либо R в цикле;
- Важно определить фиктивный массив и критерий сравнения;

Пример задачи в `answer_based_binsearch_example.cpp`;

<br>

### Взвешанная дихотомия

= Interpolation search / uniform binary search, является улучшеннием бинпоиска, так как мы вместо деления на 2 предсказываем примерное нужное нам значение функции;
- С помощью формулы мы можем примерно определить значение индекса нужного нам ключа;
- Хорошо работает с равномерно распределёнными данными, формирующими монотонно неубывающую функцию;