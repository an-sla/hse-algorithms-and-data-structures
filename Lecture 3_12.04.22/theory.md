# Задача RMQ/RSQ. Префиксные суммы, разреженные таблицы.

- Range Minimum/Maximum Query;
- Range Sum Query;
  <br>= Запросы на подотрезках;

## Префиксные суммы
- Отвечает на большое количество запросов о сумме на подотрезке от L до R;
- Хотим отвечать на каждый запрос за _O_(1);

<ins>Реализуем решение задачи о RSQ:</ins>
- Имеем исходный массив A с n элементами;
- Построим вспомогательный массив префиксных сумм P размера n+1, где в первой ячейке (по индексу 0) будет стоять 0;
- Заполним массив P по формуле: P[i] = A[i-1] + P[i-1];
- Тогда при поступлении запроса формата L, R, где это — границы массива с включёнными крайними элементами, мы сможем возвращать S = P[R] - P[L-1] (делаем L-1, чтобы вычитать не включая левый элемент);
- При реализации на C++, получение ответа будет занимать _O_(1), так как это сложность обращения к элементу массива, а здесь мы делаем два раза обращение и один раз берём разность двух чисел;

**Пример:**
| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | 
| A | 7 | -2 | 3 | 1 | 4 | 0 | -3 | 5 | 4 | 8 |  |
| P | 0 | 7 | 5 | 8 | 9 | 13 | 13 | 10 | 15 | 19 | 27 |


Пример задачи в `RSQ.cpp`;
<br>

<ins>Реализуем решение задачи о максимальной сумме на подотрезке в массиве целых чисел:</ins>
- Хотим найти такие L, R, чтобы на данном подотрезке была максимальная сумма с учётом отрицательных элементов;
- Имеем исходный массив A с n элементами;
- Опять построим вспомогательный массив префиксных сумм P размера n+1, где в первой ячейке (по индексу 0) будет стоять 0;
- Заполним массив P по формуле: P[i] = A[i-1] + P[i-1];
- Дальше для каждого данного R нам выгоднее всего брать минимальный L на отрезке от 0, R-1, так как для подсчёта суммы мы будем вычитать из значения по индексу R значение по выбранному индексу L: S = P[R] - P[L-1];
- Для быстрого подсчёта посчитаем для каждого индекса во втором вспомогательном массиве L индекс исторического минимума для каждого R_i, т.е. текущего индекса в M или M[i];

**Пример:**
| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | 
| A | 7 | -2 | 3 | -10 | -6 | 0 | -3 | 10 | 4 | 8 |  |
| P | 0 | 7 | 5 | 8 | -2 | -8 | -8 | -11 | -1 | 3 | 11 |
| L | 0 | 0 | 0 | 0 | 0 | 5 | 6 | 6 или 7 | 8 | 8 | 8 |

<br>

<ins>Реализуем решение задачи о сумме на подматрице в массиве массивов:</ins>
- Имеем исходную матрицу A размера n x m;
- Строим фиктивные -1-й столбец и -1-ю строку и заполняем нулями;
- Строим двумерный массив P префиксных сумм размера n x m;
- P[i][j] — сумма всех элементов от P[0][0] до P[i][j] включительно;
- Далее для подсчёта суммы на подматрице используем формулу включений-исключений:
  - Если хотим сумму на подматрице с координатами [i_1][j_1] до [i_2][j_2], то это будет:
    S = P[i_2][j_2] - P[i_1 - 1][j_2] - P[i_2][j_1 - 1] + P[i_1][j_1];

![image_1578762431](https://user-images.githubusercontent.com/101647250/167165946-f1018997-7f34-46d1-8d52-baaa287cc39e.png)

Пример задачи в `RSQ_2Dmatrix.cpp`;

<br>

## Sparse table

- Используется при многочисленных запросах о минимуме на подотрезке массива;
- Алгоритм имеет сложность О(N * log2 (N)) по памяти и по времени;

<br>
<ins>Реализуем алгоритм sparse table на 1D массиве:</ins>

1. Имеем исходный массив А размера N;
2. Составим 2D массив S, где первая строка будет нашим исходным массивом A, а каждая следующая будет постепенно уменьшаться;
3. Всего будет ≥ log2 (N) строк;
4. Каждая клетка S[i][j] = min(A[i, i + 2^j -1]);
5. Каждая клетка новой строки вычисляется как min() из 2 клеток предыдущей строки;

![output-onlinepngtools-11](https://user-images.githubusercontent.com/101647250/167172951-b8769755-e859-44c4-87b8-37b367382157.png)

Пример задачи в `sparse_table_1D.cpp`;