#include <iostream>
#include <vector>

// РЕШАЕМ ЗАДАЧУ ПОСТРОЕНИЯ ДЕРЕВА КРАТЧАЙШИХ РАССТОЯНИЙ ДЛЯ ОРГРАФА:
// (отсуствие цикла отрицательной длины гарантировано)

const int inf = 1e9;

struct edge {
    // f – откуда, t – куда, w – вес
    int f = 0, t = 0, w = 0;
};

int main() {
    // n – количество вершин, m – количество рёбер, vertex – корень дерева кратчайших расстояний
    int n, m, vertex;
    std::cin >> n >> m >> vertex;
    std::vector<edge> e(m); // список рёбер

    // инициализация графа с помощью списка рёбер (матрицы инцидентности)
    for (int i = 0; i < m; ++i) {
        std::cin >> e[i].f >> e[i].t >> e[i].w;
    }

    std::vector<int> p(n, -1); // список предков = наше дерево кратчайших расстояний
    std::vector<int> dist(n, inf); // массив построенных расстояний

    dist[vertex] = 0; // расстояние до корня дерева фиксируем равным 0

    for (int k = 0; k < n - 1; ++k) { // идём по фазам — (n - 1) штука, макс. количество рёбер в дереве кратчайших расстояний
        for (int i = 0; i < e.size(); ++i) { // идём по всем рёбрам
            int f = e[i].f, t = e[i].t, w = e[i].w;
            if (dist[f] == inf) { // если расстояние до исходящей вершины для данного ребра = бесконечности, пропускаем, не можем произвести релаксацию (=улучшение), мы до неё ещё не ходили, чтобы из неё пойти дальше
                continue;
            }
            // если мы уже как-то дошли до вершины to... смотрим, можем ли мы пойти в вершину to, улучшив расстояние;
            // если расстояние до to = inf (мы не ходили в to до этого), то это уже будет больше, чем путь до from + вес, т.е. улучшаем;
            // если мы в течении цикла улучшили расстояние до from, то мы итеративно улучшаем (пересчитываем) расстояния до to:
            if (dist[f] + w < dist[t]) { // если расстояние есть, но мы знаем, что можем улучшить — улучшаем
                dist[t] = dist[f] + w; // фиксируем новое расстояние
                p[t] = f; // фиксируем нового предка
            }
        }
    }

    // вывод дерева кратчайших расстояний:
    for (int i = 0; i < p.size(); ++i) {
        if (p[i] == -1) { // (если предка нет, не выводим ничего)
            continue;
        }
        std::cout << p[i] << "->" << i << ";" << std::endl;
    }
    return 0;
}

/*
Test Input:
8 10 2
0 1 3
0 5 -1
1 2 6
2 4 2
2 3 6
3 4 6
3 5 3
5 6 -2
6 4 -2
6 7 7

Test Output:
2->3;
2->4;
3->5;
5->6;
6->7;
*/