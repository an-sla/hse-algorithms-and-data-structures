# Повтор. Куча. Дерево отрезков.

## Дерево отрезков
Дерево отрезков это структура данных, позволяющая быстро отвечать на запросы на отрезках. Запросы могут быть вида **RMQ / RSQ / GCD**  и так далее. 

Строится в виде дерева, где первый слой это исходный массив **A**, а последующие слои это массивы в **2** раза меньше предыдущих, которые состоят из ответов для отрезка [**L<sub>i</sub>, R<sub>i</sub>**] длины **2**. Каждый новый слой повторяет концепцию предыдущего.

### Асимптотика 
* Сложность по времени: $O(n\cdot log(n))$
 * Сложность по памяти: $O(log(n))$


### Реализация

 <ins>На одномерном массиве:</ins>
 
 К исходному массиву создаётся ещё один массив длины $\mathbf{n\cdot2}$
 
**1- ым** элементом будет результат на всём массиве — **[0; n)**  (то есть корень дерева). 

**2 - ым** и **3 - им** элементами будут потомки этого корня — **[$0;\mathbf{\frac{n}{2}}$)** и **[$\mathbf{\frac{n}{2}}; n$)**.

С **4 - го** по **5 - ый** будут потомки **второго**: **[$0; \mathbf{\frac{n}{4}}$)** и **[$\mathbf{\frac{n}{4}}; \mathbf{\frac{n}{2}}$)** 
А на **6 - ой** и **7 - ой** будут потомки **третьего**:  **[$\mathbf{\frac{n}{2}}; \mathbf{\frac{n}{2} + 2}$)**  и **[$\mathbf{\frac{n}{2} + 2}; \mathbf{n}$)** 

**....**

Последние **n** элементов будет занимать исходный массив. 

* Если количество элементов массива $\ne 2^i$ , то массив придётся выравнивать 
 — заполнять такими элементами пустые клетки, чтобы они не мешали функции подсчёта.

<ins>На куче:</ins>

Строится гораздо проще, левый потомок задаётся формулой $\mathbf{2k + 1}$, правый потомок $\mathbf{2k + 2}$, а чтобы высчитать родителя достаточно посчитать $\mathbf{\frac{k - 1}{2}}$.

Для реализации на дереве достаточно массива из $\mathbf{n\cdot4}$ элементов.

Функция построения будет принимать границы $l_i$ и $r_i$  и индекс вершины $v$, затем вычислять середину между $l_i$ и $r_i$ запросам и строить левого и правого потомка, а после класть значение: $tree[v] = func(a)$.

#### Ответы на запросы
- Будем называть $lq$ и $rq$ — границами запроса. Тогда если эти границы полностью вошли в границы вершины, то мы можем сразу получить ответ. 
- Если же отрезок, отвечающий за вершину, как-то пересекается с отрезком запроса $lq$ и $rq$, то мы должны рекурсивно перейти к потомкам и вычислить у них значения.
- Иначе отрезок находится либо справа от запроса, либо слева и мы не можем ответить на запрос, поэтому возвращаем мусорное (неломающее ответ) значение.